# Описание ISA SARCH

## Регистры
В ISA всего 9 32-битных регистров общего назначения: от `r0` до `r7` включительно и `rsp`.
`rsp` указывает на вершину стека. Стек растёт вниз.

Также есть 1-битный регистр "флаг". Прочитать его значение напрямую нельзя. Записать его
значение напрямую нельзя.

Кроме того, есть 32-битный регистр "instruction pointer". Прочитать его значение
напрямую нельзя. Записать его напрямую нельзя.

## Immediates
Во всех инструкциях, кроме `jmp` и `cjmp`, значение `imm` должно быть
целым числом от `0x0` до `0xFFFF` включительно. При присваивании
`imm` в регистр или ячейку памяти производится zero extend.

Формат сдвига в `jmp` и `cjmp` на момент этого задания пока не оговаривается.
Представим, что ассемблер магически преобразует метки в нужным образом
закодированную часть инструкции.

## Инструкции
### Присваивание
- `asgn reg1 reg2` &mdash; `reg1 = reg2`
- `asgn reg imm` &mdash; `reg = imm`

### Арифметика
- `add reg1 reg2` &mdash; `reg1 += reg2`
- `add reg1 imm` &mdash; `reg1 += imm`
- `sub reg1 reg2` &mdash; `reg1 -= reg2`
- `sub reg1 imm` &mdash; `reg1 -= imm`
- `mul reg1 reg2` &mdash; `reg1 *= reg2`
- `mul reg1 imm` &mdash; `reg1 *= imm`
- `div reg1 reg2` &mdash; `reg1 /= reg2`
- `div reg1 imm` &mdash; `reg1 /= imm`

Умножение и деление знаковые.

### Битовые операции
- `xor reg1 reg2` &mdash; `reg1 ^= reg2`

### Сравнение
Команда имеет вид `cmp? reg1 reg2` или `cmp? reg imm`. Команда записывает
свой результат в регистр "флаг". `?` может быть
- `eq` &mdash; аргументы равны
- `ne` &mdash; аргументы не равны
- `lt` &mdash; первый аргумент меньше второго (регистры интерпретируются как знаковые)
- `le` &mdash; первый аргумент не больше второго (регистры интерпретируются как знаковые)
- `gt` &mdash; первый аргумент больше второго (регистры интерпретируются как знаковые)
- `ge` &mdash; первый аргумент не меньше второго (регистры интерпретируются как знаковые)
- `b` &mdash; первый аргумент меньше второго (регистры интерпретируются как беззнаковые)
- `be` &mdash; первый аргумент не больше второго (регистры интерпретируются как беззнаковые)
- `a` &mdash; первый аргумент больше второго (регистры интерпретируются как беззнаковые)
- `ae` &mdash; первый аргумент не меньше второго (регистры интерпретируются как беззнаковые)

### Control flow
Переходы пока что производятся волшебным образом только на метку

- `jmp label` &mdash; безусловный переход
- `cjmp label` &mdash; переход, только если значение регистра "флаг" равно `1`

### Работа с памятью
Указатели считаются `void*`. Их можно двигать по одному байту и записывать
память без выравнивания.

- `load reg1 reg2` &mdash; `reg1 = *((uint32_t*) reg2)`
- `store reg1 reg2` &mdash; `*((uint32_t*) reg1) = reg2`
- `store reg imm` &mdash; `*((uint32_t*) reg) = imm`

Аллокация памяти не предусмотрена. Доступен только преаллоцированный стек.

### Работа с графикой
- `putpx reg_x reg_y reg_argb` &mdash; `simPutPixel(reg_x, reg_y, reg_argb)`
- `putpx reg_x reg_y imm_argb` &mdash; `simPutPixel(reg_x, reg_y, imm_argb)`.
    К `imm` применяется zero extend, поэтому любое значение `imm_argb` эквивалентно
    `0`, то есть полностью прозрачному цвету
- `flush` &mdash; `simFlush()`

